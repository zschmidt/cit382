
<!DOCTYPE html>

<html>
  <head>
    <title>Canvas Surface Rotation</title>
    <style>
      body {
        text-align: center;
      }
      
      canvas {
        border: 1px solid black;
      }
    </style>
    <script>   
      var constants = {
        leftArrow: 37,
        upArrow: 38,
        rightArrow: 39,
        downArrow: 40,
        xMin: -9, // These four max/min values define a square on the xy-plane that the surface will be plotted over.
        xMax: 9,
        yMin: -9,
        yMax: 9, 
        xDelta: 0.2, // Make smaller for more surface points. 
        yDelta: 0.2, // Make smaller for more surface points. 
        colorMap: ["#060", "#090", "#0C0", "#0F0", "#9F0", "#9C0", "#990", "#960", "#930", "#900", "#C00"],
        pointWidth: 2, // The size of a rendered surface point (i.e., rectangle width and height) in pixels.
        dTheta: 0.05, // The angle delta, in radians, by which to rotate the surface per key press.
        surfaceScale: 24 // An empirically derived constant that makes the surface a good size for the given canvas size.
      };
      
      // These are constants too but I've removed them from the above constants literal to ease typing and improve clarity.
      var X = 0;
      var Y = 1;
      var Z = 2;

      // -----------------------------------------------------------------------------------------------------  

      var surface = new Surface(); // A set of points (in vector format) representing the surface.

      // -----------------------------------------------------------------------------------------------------

      function point(x, y, z)
      {       
        return [x, y, z]; 
      }
      
      // -----------------------------------------------------------------------------------------------------
      
      function Surface()
      /*
        A surface is a list of (x, y, z) points, in 3 x 1 vector format. This is a constructor function.
      */
      {
        this.points = []; // An array of surface points in vector format. That is, each element of this array is a 3 x 1 array, as in [ [x1, y1, z1], [x2, y2, z2], [x3, y3, z3], ... ]
      }
      
      // -----------------------------------------------------------------------------------------------------  
      
      Surface.prototype.equation = function(x, y)
      /*
        Given the point (x, y), returns the associated z-coordinate based on the provided surface equation, of the form z = f(x, y).
      */
      {
        var d = Math.sqrt(x*x + y*y); // The distance d of the xy-point from the z-axis.
        
        return 4*(Math.sin(d) / d); // Return the z-coordinate for the point (x, y, z). 
      }
      
      // -----------------------------------------------------------------------------------------------------  
      
      Surface.prototype.generate = function()
      /*
        Creates a list of (x, y, z) points (in 3 x 1 vector format) representing the surface.
      */
      {
        var i = 0;
        
        for (var x = constants.xMin; x <= constants.xMax; x += constants.xDelta)
        {
          for (var y = constants.yMin; y <= constants.yMax; y += constants.yDelta)
          {
            this.points[i] = point(x, y, this.equation(x, y)); // Store a surface point (in vector format) into the list of surface points.              
            ++i;
          }
        }
      }

      // -----------------------------------------------------------------------------------------------------
            
      Surface.prototype.color = function()
      /*
        The color of a surface point is a function of its z-coordinate height.
      */
      {
        var z; // The z-coordinate for a given surface point (x, y, z).
        
        this.zMin = this.zMax = this.points[0][Z]; // A starting value. Note that zMin and zMax are custom properties that could possibly be useful if this code is extended later.
        for (var i = 0; i < this.points.length; i++)
        {            
          z = this.points[i][Z];
          if (z < this.zMin) { this.zMin = z; }
          if (z > this.zMax) { this.zMax = z; }
        }   
              
        var zDelta = Math.abs(this.zMax - this.zMin) / constants.colorMap.length; 

        for (var i = 0; i < this.points.length; i++)
        {
          this.points[i].color = constants.colorMap[ Math.floor( (this.points[i][Z]-this.zMin)/zDelta ) ];
        }
      }

      // -----------------------------------------------------------------------------------------------------


      Surface.prototype.sortByZIndex = function(A, B) 
      {
        return A[Z] - B[Z]; // Determines if point A is behind, in front of, or at the same level as point B (with respect to the z-axis).
      }


      // -----------------------------------------------------------------------------------------------------
            
      Surface.prototype.draw = function()
      {
        var myCanvas = document.getElementById('myCanvas');
        var ctx = myCanvas.getContext("2d");

        myCanvas.width = myCanvas.width; //clear the canvas

        ctx.translate(myCanvas.height/2,myCanvas.width/2); // Translate the surface's origin to the center of the canvas.

        this.points = surface.points.sort(surface.sortByZIndex);

        for (var i = 0; i < this.points.length; i++)
        {
          ctx.fillStyle = this.points[i].color; 
          ctx.fillRect(this.points[i][X] * constants.surfaceScale, this.points[i][Y] * constants.surfaceScale, constants.pointWidth, constants.pointWidth);  
        }    
      }
      
      // -----------------------------------------------------------------------------------------------------
      
      Surface.prototype.multi = function(R)
      /*
        Assumes that R is a 3 x 3 matrix and that this.points (i.e., P) is a 3 x n matrix. This method performs P = R * P.
      */
      {
        var Px = 0, Py = 0, Pz = 0; // Variables to hold temporary results.
        var P = this.points; // P is a pointer to the set of surface points (i.e., the set of 3 x 1 vectors).
        var sum; // The sum for each row/column matrix product.
  
        for (var V = 0; V < P.length; V++) // For all 3 x 1 vectors in the point list.
        {
          Px = P[V][X], Py = P[V][Y], Pz = P[V][Z];
          for (var Rrow = 0; Rrow < 3; Rrow++) // For each row in the R matrix.
          {
            sum = (R[Rrow][X] * Px) + (R[Rrow][Y] * Py) + (R[Rrow][Z] * Pz);
            P[V][Rrow] = sum;
          }
        }     
      }

      // -----------------------------------------------------------------------------------------------------

      Surface.prototype.xRotate = function(sign)
      /*
        Assumes "sign" is either 1 or -1, which is used to rotate the surface "clockwise" or "counterclockwise".
      */
      {
        var cosTheta = Math.cos( sign*constants.dTheta );
        var sinTheta = Math.sin( sign*constants.dTheta );

        var Rx = [ [1, 0, 0],
                   [0, cosTheta, -1*sinTheta],
                   [0, sinTheta, cosTheta] ];
        
        this.multi(Rx); // If P is the set of surface points, then this method performs the matrix multiplcation: Rx * P
        this.draw();
      }
         
      // -----------------------------------------------------------------------------------------------------
         
      Surface.prototype.yRotate = function(sign)
      /*
        Assumes "sign" is either 1 or -1, which is used to rotate the surface "clockwise" or "counterclockwise".
      */      
      {
        var cosTheta = Math.cos( sign*constants.dTheta );
        var sinTheta = Math.sin( sign*constants.dTheta );
        var Ry = [ [cosTheta, 0, sinTheta],
                   [0, 1, 0],
                   [-1*sinTheta, 0, cosTheta] ];
        
        this.multi(Ry); // If P is the set of surface points, then this method performs the matrix multiplcation: Rx * P
        this.draw();
      }
     
      // -----------------------------------------------------------------------------------------------------

      function processKeyDown(evt)
      {
        switch (evt.keyCode)
        {
          case constants.upArrow:
            evt.preventDefault();
            surface.xRotate(1);
            break;
          case constants.downArrow:
            evt.preventDefault();
            surface.xRotate(-1);
            break;
          case constants.leftArrow:
            evt.preventDefault();
            surface.yRotate(-1); 
            break;
          case constants.rightArrow:
            evt.preventDefault();
            surface.yRotate(1);   
            break;
        }
      }
               
      // -----------------------------------------------------------------------------------------------------
      
      function onloadInit()
      {
        surface.draw(); // Draw the surface on the canvas.
        document.addEventListener('keydown', processKeyDown, false); // Used to detect if the control key has been pressed.
      }

      // -----------------------------------------------------------------------------------------------------
      
      surface.generate(); // Creates the set of points reprsenting the surface. Must be called before color().
      surface.color(); // Based on the min and max z-coordinate values, chooses colors for each point based on the point's z-ccordinate value (i.e., height).
      window.addEventListener('load', onloadInit, false); // Perform processing that must occur after the page has fully loaded.
    </script>
  </head>
  <body>
    <h1>Canvas Surface Rotation</h1>
    <canvas id="myCanvas" height="600px" width="600px"></canvas>
  </body>
</html>